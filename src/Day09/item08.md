# 2021-04-07 /2021-04-23

#Item08. Finalizer와 Cleaner 쓰지 마세요.
=======================================================
- 두 가지 객체의 소멸자를 제공(finalizer, cleaner)
  1) finalizer, cleaner는 즉시 수행된다는 보장이 없다. -> finalizer와 cleaner로는 재떄 실행되어야 한느 작업은 절대 할 수 없다.
  2) 공유자원의 영구 락(lock) 해제를 finalizer나 cleaner에 맡겨 놓으면 분산 시스템 전체가 서서히 멈출것이다.
     : finalizer나 cleaner의 수행시점 뿐만 아니라 수행여부조차 보장하지 않기 때문.
  3) System.gc나 System.runFinalization 메서드에 현혹되지 말것. -> finalizer나 cleaner가 실행될 가능성을 높여 줄 수 는 있지만, 보장해 주지는 않는다.
    보장해주겟다는 메서드(SYstem.runFinalizersOnExit, Runtime.runFinalizersOnExit) 이 있으나 결함으로 인해 사용이 어려움.
  4) 심각한 성능 문제
  5) finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수 있다.
      : 생성자와 직렬화과정에서 예외가 발생하면, 생성되다가 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될수 있다.
        이 finalizer는 정적 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하게 막을 수 있다.   
        객체의 메서드를 호출해 애초에는 허용되지 않았을 작업을 수행하는건 일도 아니다. 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로도 충분하지만,
        finalizer가 있다면 그렇지도 않다. final 클래스들은 그 누구도 하위 클래스를 만들 수 없으니 안전하다. 
        final이 아닌 클래스를 finalizer 공격을 막으러면 아무일도 하지 않는 finalize메서드를 만들고 final로 선언해야 한다.
  
**AutoCloseable을 구형해주고, 클라이언트에서 인스턴스르 다 쓰고 나면 close 메서드를 호출하면 된다.
  (일반적으로 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용해야 한다.)
  각 인스턴스는 자신이 닫혔는지를 추적하는 것이 좋다. 다시 말해 close메서드에서 이 객체는 더 이상 유효하지 않음을 필드에 기록하고, 다른 메서드는 이필드를 검사해서
  객체가 닫힌 후에 불렸다면 IllegalStaeteException을 던지는 것이 좋다.**


> finalizer와 cleaner 사용 예시
> 1. 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할
> 2. 네이티브 피어와 연결된 객체에서 사용. 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다.
>    네이티브 피어는 일반 자바 객체가 아니므로 가비지 컬렉터는 그 존재를 알 지 못한다. 그 결과 자바 피어를 회수할 때 네이티브 객체까지 회수하지 못한다.
>    cleaner와 finalizer가 나서서 처리하기에 적당한 작업. -> 단, 성능저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때만 해당한다. 성능 저하를 감당할 수 없거나 네이티브 피어가
>    사용하는 자원을 즉시 회수해야 한다면 close 메서드를 사용해야 한다.

**cleaner는 안전망 역할이니 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 물론 이런 경우라도 불확실성과 성능 저하에 주의해야 한다.**